// TB CSM 2022-06-28: v23 re-commenting the defaults to avoid quoted strings in output
# TB CSM 2022-05-17: V22 add explicit definition of LED strings used in firmware, no Orange in fgSavingRec & fgUSB_MSC
# TB CSM 2022-05-16: V21 saveRec(sv), add timeout to pause, shutting down LED(R) not bgLED
# TB CSM 2022-04-27: V20 One touch recording
# TB CSM 2022-04-04: V19 handle battery events in USB mode
# TB CSM 2022-03-08: V18 TBv1 compatible file names.
# TB CSM 2022-03-02: V17 handle BattMin & BattMax events
# TB CSM 2022-02-23: V16 starTree => play all subj messages in a loop
# TB CSM 2022-02-21: V15 8 sec pause => stGoSleep, Circle__ => stChgPkg, starCircle => stNxtPkg, handle LowBattery,BattCharging,& BattCharged
# TB CSM 2022-01-28: V14 Home__ to stGoSleep
# TB CSM 2021-10-20: V13 Star_Tree repeats msg for battery testing
# TB CSM 2021-10-05: V12 QC tune changes, longer recording (Bill)
# TB CSM 2021-09-23: V11 QC test-- skip on Star after Home
# TB CSM 2021-05-19: V10 QC test-- each key beeps
# TB CSM 2021-05-19: V9 rewrote QC test
# TB CSM 2021-05-12: V8 with QC test
# TB CSM 2021-04-22: V7 fix anyKey, remove noDevUpdate, stFbOptions: rh_things_to_do
# TB CSM 2021-04-16: V6 Add interstitial states to allow skipping through prompts
# TB CSM 2021-04-09: V5 9Apr21 merged into Bill's version
# TB CSM 2021-04-07: V4 7Apr21 starPot: nxtPkg, starRH: chgPkg
# TB CSM 2021-04-01: V3 Star: saveRec
# TB CSM 2021-03-05: V2 stPlayPause adds CGroup whenPlayPaused
# TB CSM 2021-03-05: V1 finishRec => whenNav, circle to start/stop recording
# TB CSM 2021-03-02: V0 original version
{
  config: {
      default_volume:      4,
      minShortPressMS:    50,
      minLongPressMS:   1000,
      shortIdleMS:      5000,
      longIdleMS:     180000,
      powerCheckMS:   180000,
      qcTestState:  stQcTest,
      initState:    stWakeup,
#      bgPulse:        "_49G",                           # while awake
#      fgPlaying:      "G!",                             # while playing
#      fgPlayPaused:   "G2_3!",                          # while playback is paused
#      fgRecording:    "R!",                             # while recording
#      fgRecordPaused: "R2_3!",                          # while recording is paused
#      fgSavingRec:    "R_g_!",                          # after recording, not saved or canceled
#      fgSaveRec:      "G3_3G3",                         # starting to encrypt user message
#      fgCancelRec:    "R3_3R3",                         # starting to delete user message
#      fgUSB_MSC:      "O5o5!",                          # when USB is connected in mass storage mode
#      fgTB_Error:     "R8_2R8_2R8_20!",                 # after unrecoverable firmware error
#      fgNoUSBcable:   "_3R3_3R3_3R3_5!",                # if startUSB when USB power not connected
#      fgUSBconnect:   "G5g5!",                          # when startUSB is connecting
#      fgPowerDown:    "G_3G_3G_9G_3G_9G_3",             # not generated by firmware
#      # fgStartup:   "R3_3G3",                         # when booting, before control manager
#      # fgNOR_Erasing: "R6G5!",                        # while erasing NorLog
#      # battCharge:  four half second flashes  GGGG >90%,  RGGG >75%, RRGG >60%,  RRRG >10%, RRRR <10%
  },
  CGroups: {
    whenSleeping:  { Home:       stWakeup,
                     Circle:     stWakeup },
    whenAwake:     { Home:       stWakeup,
                     Home__:     stGoSleep,
                     LongIdle:   stSleepy,
                     BattCharging: stOnCharging,
                     BattCharging75: stOnCharging75,
                     BattMax:    stNearCharged,
                     BattCharged: stOnCharged,
                     LowBattery: stOnLowBatt,
                     BattNotCharging: stNotCharging,
                     BattMin:    stOnBattMin,
                     starPlus:   stUSBmode,
                   },
    whenUSB:       { starPlus:   stCloseUSB,
                     LowBattery: stOnLowBatt,
                     BattCharging:stOnCharging,
                     BattCharged:stOnCharged,
                     BattMin:    stOnBattMin,
                     BattMax:    stNearCharged
                   },
    whenPlaying:   { Plus:       stPlayLouder,
                     Minus:      stPlaySofter,
                     Pot:        stPlayPause,
                     Lhand__:    stPlayJumpBack,
                     Rhand__:    stPlayJumpFwd },
    whenPlayPaused:{ Pot:        stPlayResume },
    whenNav:       { Lhand:      stOnPrevSubj,
                     Rhand:      stOnNextSubj,
                     Tree:       stOnNextMsg,
                     Tree__:     stOnRepeatMsg,
                     Table:      stOnPrevMsg,
                     AudioDone:  stWait,
                     ShortIdle:  stWait,
                     Star:       stBeginRecording },

    whenRecording:       { Pot:     stRecordingPaused
                           Star:    stRecordingDone },
    whenRecordingPaused: { Pot:     stRecordingResumed },
    reviewNav:           { Home:    stEndRecordingHome,
                           Star:    stRecordAnother,
                           Tree:    stEndRecording,
                           Table:   stEndRecording,
                           Lhand:   stEndRecording,
                           Rhand:   stEndRecording,
                           Circle:  stEndRecording },
    whenReviewing:       { Pot:     stReviewPaused,
                           Plus:    stReviewLouder,
                           Minus:   stReviewSofter },
    whenReviewPaused:    { Pot:     stReviewResumed },

    whenIdle:      { starPlus:   stUSBmode,
                     Plus:       stIdleLouder,
                     Minus:      stIdleSofter,
#                    starTable:  stTest,
                     starMinus:  stShowBatt,
                     Circle__:   stChgPkg,
                     starCircle: stNxtPkg },
    whenTestDone:  {  Star: stQcUSB,  Table: stQcTest,  Home: stQcReboot, Pot: stQcSysTest  },
  },
  CStates: {
    stWakeup:       { Actions: [ LED(_), bgLED(bgPulse), changePkg, playSys(10) ], CGroups:[ whenAwake, whenPlaying, whenNav ], AudioStart: stWelcoming },
    stWelcoming:    {                                                           CGroups:[ whenAwake, whenPlaying, whenNav ], AudioDone: stPromptSubj },
    stPromptSubj:   { Actions: [ playSys(11) ],                                 CGroups:[ whenAwake, whenPlaying, whenNav ], AudioStart: stPromptingSub },
    stPromptingSub: {                                                           CGroups:[ whenAwake, whenPlaying, whenNav ], AudioDone: stWait },

    stWait:         {                                                           CGroups:[ whenAwake, whenNav, whenIdle ] },
    stSleepy:       { Actions: [ bgLED(O_9), saveSt(1), setTimer(5000) ],       CGroups:[ whenAwake ], anyKey: stUnSleepy, Timer: stGoSleep },
    stUnSleepy:     { Actions: [ bgLED(bgPulse), goSavedSt(1) ],                CGroups:[ whenAwake ] },
    stGoSleep:      { Actions: [ playTune(H/+), bgLED(_), LED(R), setTimer(1000) ], CGroups:[ whenSleeping ], Timer: stFallAsleep },
    stFallAsleep:   { Actions: [ powerDown ],                                   CGroups:[ whenSleeping ] },

    stPlayLouder:   { Actions: [ volAdj( 1),  goPrevSt ],                       CGroups:[ whenAwake, whenPlaying ] },
    stPlaySofter:   { Actions: [ volAdj(-1),  goPrevSt ],                       CGroups:[ whenAwake, whenPlaying ] },
    # It would be nice to reference "long idle" here.
    stPlayPause:    { Actions: [ saveSt( 2),  setTimer(180000), pausePlay ],    CGroups:[ whenAwake, whenPlaying, whenNav, whenPlayPaused ], Timer:stSleepy },
    stPlayResume:   { Actions: [ resumePlay,  goSavedSt(2) ],                   CGroups:[ whenAwake, whenPlaying, whenNav ] },
    stPlayJumpBack: { Actions: [ posAdj(-7), goPrevSt ],                        CGroups:[ whenAwake, whenPlaying, whenNav ] },
    stPlayJumpFwd:  { Actions: [ posAdj(60), goPrevSt ],                        CGroups:[ whenAwake, whenPlaying, whenNav ] },

    stOnPrevSubj:   { Actions: [ subjAdj(-1),  playSubj(nm) ],                  CGroups:[ whenAwake, whenPlaying, whenNav ], AudioStart: stAnnouncing },
    stOnNextSubj:   { Actions: [ subjAdj( 1),  playSubj(nm) ],                  CGroups:[ whenAwake, whenPlaying, whenNav ], AudioStart: stAnnouncing },
    stAnnouncing:   {                                                           CGroups:[ whenAwake, whenPlaying, whenNav ], AudioDone: stInvitation },
    stInvitation:   { Actions: [ playSubj(pr) ],                                CGroups:[ whenAwake, whenPlaying, whenNav ], AudioDone: stPromptNextSubj },
    stPromptNextSubj:{ Actions: [ playSys(41) ],                                CGroups:[ whenAwake, whenPlaying, whenNav ] },
    stOnPrevMsg:    { Actions: [ msgAdj( -1),  playSubj(msg) ],                 CGroups:[ whenAwake, whenPlaying, whenNav ], AudioStart: stPlaying },
    stOnNextMsg:    { Actions: [ msgAdj(  1),  playSubj(msg) ],                 CGroups:[ whenAwake, whenPlaying, whenNav ], AudioStart: stPlaying },
    stPlaying:      {                                                           CGroups:[ whenAwake, whenPlaying, whenNav ], AudioDone: stInterMsg },
    stInterMsg:     { Actions: [ playSys(9) ],                                  CGroups:[ whenAwake, whenPlaying, whenNav ], AudioDone: stWait },
    
    stOnRepeatMsg:  { Actions: [ msgAdj(  1),  playSubj(msg) ],                 CGroups:[ whenAwake, whenPlaying, whenNav ], AudioStart: stRepeating },
    stRepeating:    {                                                           CGroups:[ whenAwake, whenPlaying, whenNav ], AudioDone: stOnRepeatMsg },

    #
    # One-touch implementation of recording
    #
    stBeginRecording:   { Actions: [ saveSt(2), playSys(1) ],                   CGroups:[ whenAwake, whenRecording], AudioDone: stRecording },
    stRecordAnother:    { Actions: [ playSys(1) ],                              CGroups:[ whenAwake, whenRecording], AudioDone: stRecording },
    # Start recording and time out after 30 minutes. 30*60*1000 = 1800000 ms
    stRecording:        { Actions: [ setTimer(1800000), startRec ],             CGroups:[ whenAwake, whenRecording], Timer: stRecordingDone },
    stRecordingPaused:  { Actions: [ saveSt(3), pauseRec ],                     CGroups:[ whenAwake, whenRecordingPaused] },
    stRecordingResumed: { Actions: [ resumeRec, goSavedSt(3) ],                 CGroups:[ whenAwake, whenRecording] },

    stRecordingDone:    { Actions: [ finishRec, playSys(3) ],                   CGroups:[ whenAwake], AudioDone: stReviewing },
    stReviewing:        { Actions: [ playRec ],                                 CGroups:[ whenAwake, reviewNav, whenReviewing ], AudioDone: stEndRecording },
    stReviewLouder:     { Actions: [ volAdj(1), goPrevSt ],                     CGroups:[ whenAwake, reviewNav, whenReviewing ] },
    stReviewSofter:     { Actions: [ volAdj(-1), goPrevSt ],                    CGroups:[ whenAwake, reviewNav, whenReviewing ] },
    stReviewPaused:     { Actions: [ saveSt(3), pausePlay ],                    CGroups:[ whenAwake, reviewNav, whenReviewPaused ] },
    stReviewResumed:    { Actions: [ resumePlay, goSavedSt(3) ],                CGroups:[ whenAwake, reviewNav, whenReviewing ] },

    stEndRecording:     { Actions: [ saveRec(sv), LED(_), goSavedSt(2) ] },
    stEndRecordingHome: { Actions: [ saveRec(sv), setTimer(100) ],              Timer: stWakeup },


    stIdleLouder:   { Actions: [ volAdj( 1), playSys(0),  goPrevSt ],           CGroups:[ whenAwake, whenPlaying ] },
    stIdleSofter:   { Actions: [ volAdj(-1), playSys(0),  goPrevSt ],           CGroups:[ whenAwake, whenPlaying ] },
    stUSBmode:      { Actions: [ bgLED(R2_8G2_8), startUSB ],                   CGroups:[ whenUSB ] },
    stCloseUSB:     { Actions: [ endUSB, bgLED(G_29), setTimer(1000) ],         Timer: stWakeup },

    stShowBatt:     { Actions: [ showCharge,  goPrevSt ],                       CGroups:[ whenAwake, whenIdle ] },

    # Charging, charge < 75% (ideally), blink red every 5 seconds
    # Charging, 75% < charge < 90% (ideally), blink green every 5 seconds
    # Charging, 90% < charge < 100% (ideally), double blink green every 5 seconds.
    # Charged. Lights off
    # Battery > 20%, not charging: Lights off
    # Battery low: charge < 20%, blink red every 2 seconds
    # Battery at minimum: not enough juice to run. Two seconds of red, then back to sleep.
    stOnCharging:   { Actions: [ bgLED(R_49),  goPrevSt ],                      CGroups:[ whenAwake, whenIdle ] },
    stOnCharging75: { Actions: [ bgLED(G_49),  goPrevSt ],                      CGroups:[ whenAwake, whenIdle ] },
    stNearCharged:  { Actions: [ bgLED(G_G_47), goPrevSt ],                     CGroups:[ whenAwake, whenIdle ] },
    stOnCharged:    { Actions: [ bgLED(_),  goPrevSt ],                         CGroups:[ whenAwake, whenIdle ] },
    stOnLowBatt:    { Actions: [ bgLED(R_19), goPrevSt ],                       CGroups:[ whenAwake, whenNav, whenIdle ] },
    stNotCharging:  { Actions: [ bgLED(_), goPrevSt ],                          CGroups:[ whenAwake, whenNav, whenIdle ] },
    stOnBattMin:    { Actions: [ bgLED(R20_30),  setTimer(5000) ],              CGroups:[ whenSleeping ], Timer: stFallAsleep },

    stNxtPkg:       { Actions: [ playNxtPkg ],                                  CGroups:[ whenAwake, whenIdle ] },
    stChgPkg:       { Actions: [ changePkg ],                                   CGroups:[ whenAwake, whenIdle, whenNav ] },

    #************************************** QC Acceptance Test ***********************************
    # QC-test: C G, Pl:E, Hm:C, Mi:(rec) E,  Tr: (ply) G, Ci: C, Lh: D, Po: E, Rh: F, St: G, Ta: E C
    #  0)          playTune(C/)
    #  1)  File:   filesTest, read & check system/QC_Test.txt         Error(filesTest) if doesn't match
    #  2)  LED G:  tune(G/), flashing G     till Plus                 or Table => Error(no_Green)  (or Green or Plus failed)
    #  3)  LED R:  tune(E/), flashing R     till Home                 or Table => Error(no_Red)    (if Red or Home failed)
    #  4)  Record: flash G once:         till Minus  or Star => Skip  or Table => Error(no_Minus)
    #  5)  Record: Red for 2 sec  while recording
    #  6)  Play:   flash G once:            till Tree  to play back   or Table => Error(no_Tree)
    #  7)  Play:   Green while playing 
    #  8)  Keys:   flash G once, tune(G/)   till Circle               or Table => Error(rec_play) (if record/playback  or Circle failed)
    #  9)  Keys:   flash G once, tune(C/)   till Lhand                or Table => Error(no_Lhand)
    # 10)  Keys:   flash G once, tune(D/)   till Pot                  or Table => Error(no_Pot)
    # 11)  Keys:   flash G once, tune(E/)   till Rhand                or Table => Error(no_Rhand)
    # 12)  Keys:   flash G once, tune(F/)   till Star                 or Table => Error(no_Star)
    # 13)  Keys:   flash G once, tune(G/)   till Table                or Star  => Error(no_Table)
    # 14)  Complete:  tune(E/C)
    # on Skip:   tune(G/C)
    # on Error: (filesTest failed or Table pressed early) tune(H.*_H.*_H.*_H.*_) flashing Red, write QC_FAIL.txt with reason, test complete
    # on Test complete: flashing G till
    #        Star:  USB mode,  Table: restart Qc test,  Home: Reboot,  Pot: play tune
    # 
    stQcTest:       { Actions: [ playTune(C/)                      ],  AudioDone: stQc1 }
    stQc1:          { Actions: [ filesTest(),bgLED(G3_3)           ],  FilesSuccess: stQc2, FilesFail: stQcErrFiles, anyKey: stQcBeep }
    stQc2:          { Actions: [ bgLED(G3_3), playTune(C/C/)       ],  Plus:  stQc3,  Table: stQcErrGrn,  Plus__:  stQc3,  Table__: stQcErrGrn,  anyKey: stQcBeep }
    stQc3:          { Actions: [ bgLED(R3_3), playTune(D/)         ],  Home:  stQc4,  Table: stQcErrRed,  Home__:  stQc4,  Table__: stQcErrRed,  anyKey: stQcBeep }
    stQc4:          { Actions: [ bgLED(_), LED(G3), playTune(E/)   ],  Minus: stQc5,  Table: stQcErrNoMi, Minus__: stQc5,  Table__: stQcErrNoMi, Star: stQcSkip, Star__:stQcSkip, anyKey: stQcBeep }
    stQc5:          { Actions: [ startRec, setTimer(4000)          ],  Timer: stQc6,  anyKey: stQc6  }
    stQc6:          { Actions: [ finishRec, playTune(F/)           ],  AudioDone: stQc6b  }
    stQc6b:         { Actions: [                                   ],  Tree:  stQc7,  Table: stQcErrNoTr, Tree__:  stQc7,  Table__: stQcErrNoTr  }
    stQc7:          { Actions: [ LED(G!), playRec                  ],  AudioDone: stQc7b  }
    stQc7b:         { Actions: [ LED(_),  playTune(G/)             ],  AudioDone: stQc8  }
    stQc8:          { Actions: [                                   ],  Circle: stQc9, Table: stQcErrPlay, Circle__: stQc9, Table__: stQcErrPlay, anyKey: stQcBeep }
    stQc9:          { Actions: [ LED(G3), playTune(A/A/)           ],  Lhand: stQc10, Table: stQcErrNoLh, Lhand__: stQc10, Table__: stQcErrNoLh, anyKey: stQcBeep }
    stQc10:         { Actions: [ LED(G3), playTune(G/)             ],  Pot:   stQc11, Table: stQcErrNoPo, Pot__:   stQc11, Table__: stQcErrNoPo, anyKey: stQcBeep }
    stQc11:         { Actions: [ LED(G3), playTune(F/)             ],  Rhand: stQc12, Table: stQcErrNoRh, Rhand__: stQc12, Table__: stQcErrNoRh, anyKey: stQcBeep }
    stQc12:         { Actions: [ LED(G3), playTune(E/)             ],  Star:  stQc13, Table: stQcErrNoSt, Star__:  stQc13, Table__: stQcErrNoSt, anyKey: stQcBeep }
    stQc13:         { Actions: [ LED(G3), playTune(D/)             ],  Table: stQc14, Star:  stQcErrNoTa, Table__: stQc14, Star__:  stQcErrNoTa, anyKey: stQcBeep }
    stQc14:         { Actions: [ playTune(C/C*)                    ],  AudioDone:  stQc15 }
    stQc15:         { Actions: [ writeMsg(QC_OK), bgLED(G2_8)      ],  CGroups: [ whenTestDone ] }
    stQcSkip:       { Actions: [ playTune(G/C)                     ],  AudioDone:  stQcSkip2 }
	stQcSkip2:      { Actions: [ writeMsg(QC_OK_short), bgLED(G2_8)],  CGroups: [ whenTestDone ] }

    stQcBeep:       { Actions: [ playTune(H_H), goPrevSt  ]   }
    stQcErrFiles:   { Actions: [ writeMsg(filesTest),bgLED(R9_6), playTune(H.*_H.*_H.*_H.*_) ], CGroups: [ whenTestDone ] }
    stQcErrGrn:     { Actions: [ writeMsg(no_Green), bgLED(R9_6), playTune(H.*_H.*_H.*_H.*_) ], CGroups: [ whenTestDone ] }
    stQcErrRed:     { Actions: [ writeMsg(no_Red),   bgLED(R9_6), playTune(H.*_H.*_H.*_H.*_) ], CGroups: [ whenTestDone ] }
    stQcErrNoMi:    { Actions: [ writeMsg(no_Minus), bgLED(R9_6), playTune(H.*_H.*_H.*_H.*_) ], CGroups: [ whenTestDone ] }
    stQcErrNoTr:    { Actions: [ writeMsg(no_Tree),  bgLED(R9_6), playTune(H.*_H.*_H.*_H.*_) ], CGroups: [ whenTestDone ] }
    stQcErrPlay:    { Actions: [ writeMsg(rec_Play), bgLED(R9_6), playTune(H.*_H.*_H.*_H.*_) ], CGroups: [ whenTestDone ] }
    stQcErrNoLh:    { Actions: [ writeMsg(no_Lhand), bgLED(R9_6), playTune(H.*_H.*_H.*_H.*_) ], CGroups: [ whenTestDone ] }
    stQcErrNoPo:    { Actions: [ writeMsg(no_Pot),   bgLED(R9_6), playTune(H.*_H.*_H.*_H.*_) ], CGroups: [ whenTestDone ] }
    stQcErrNoRh:    { Actions: [ writeMsg(no_Rhand), bgLED(R9_6), playTune(H.*_H.*_H.*_H.*_) ], CGroups: [ whenTestDone ] }
    stQcErrNoSt:    { Actions: [ writeMsg(no_Star),  bgLED(R9_6), playTune(H.*_H.*_H.*_H.*_) ], CGroups: [ whenTestDone ] }
    stQcErrNoTa:    { Actions: [ writeMsg(no_Table), bgLED(R9_6), playTune(H.*_H.*_H.*_H.*_) ], CGroups: [ whenTestDone ] }

    stQcUSB:        { Actions: [ bgLED(O2_8), startUSB ], CGroups: [ whenTestDone ] } 
    stQcReboot:     { Actions: [ sysBoot ] }  
    stQcSysTest:    { Actions: [ playTune(CG/.FDEH.G/) ], CGroups: [ whenTestDone ] }
  }   # CStates
}     # control.def

